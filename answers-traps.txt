Q1: Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

A1: a0 to a7 contain arguments; a2 holds 13.

--------------------------------------------

Q2: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

A2: There are no calls. The compiler did inline optimizations.

--------------------------------------------

Q3: At what address is the function printf located?

A3: 0000000000000630 <printf>

--------------------------------------------

Q4: What value is in the register ra just after the jalr to printf in main?

A4: 0x38
30:	00000097 auipc	ra,0x0   
# auipc: add upper immediate to pc, x[rd] = pc + sext(immediate[31:12] << 12)
# that is to save 0x30 + (0x0<<12) into ra

34:	600080e7 jalr	1536(ra)
# jalr: jump and link register, jalr rd offset(rs1), t=pc+4; pc=(x[rs1]+sext(offset))&~1; x[rd]=t
# current pc is 0x34; x[rd] = t = pc + 4 = 0x38;

--------------------------------------------

Q5: Run the following code.
	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
Here's a description of little- and big-endian and a more whimsical description.

A5: He110 World; 0x726c6400; no need;
57616 = 0xe110; 
0x72 = 114 -> r
0x6c = 108 -> l
0x64 = 100 -> d

--------------------------------------------

Q6: In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?
  printf("x=%d y=%d", 3);

A6: Register a2's value.